group persist;

// START: javaToSQLValueMap
javaToSQLValueMap ::= [
	"Date":"new java.sql.Date(<value>.getTime())",
	default : "<value>"
]
// END: javaToSQLValueMap

// START: output
output(class, fields, arrayFields, nonPrimitiveTypes) ::=
 "<serializerClass()>" // no need for ... "pass through" parameter
// END: output

// START: serializerClass
/** Inherit class, fields, arrayFields, nonPrimitiveTypes
 *  from output template that invokes me. */
serializerClass() ::= <<
// This file automatically generated by "java DBGen -java"
<imports()>
public class <class>Serializer { <! class inherited from above !>
<! END: serializerClass !>
    static int ID = 1;    
    /** Init code to set ID to it's previous value in database */
    public static void init(Connection con) throws SQLException {
        Statement stat = con.createStatement();
        ResultSet rs = stat.executeQuery("SELECT MAX(ID) from Person;");
        rs.next();
        ID = rs.getInt(1)+1;
    }
    <saveObjectMethod()>
    <arrayFields:saveForeignObjectMethod()>
    <loadObjectMethod()>
    <arrayFields:loadForeignObjectMethod()>
}
>>

// START: imports
/** Inherit attribute 'class' from serializerClass */
imports() ::= <<
<nonPrimitiveTypes:{t | import <t.name>;<\n>}>
import java.util.ArrayList; <! used by support code !>
import java.util.List;
import java.sql.*;
>>
// END: imports

// START: saveObjectMethod
saveObjectMethod() ::= <<
public static void save<class; format="capitalized">(Connection con,
                                                     Person o)
     throws SQLException
{
    PreparedStatement prep = con.prepareStatement(
       "INSERT into <class> SET ID=?, "+
       "<fields:{f | <f.name>=?}; separator=", ">;");
    int <class>_ID = ID++;
    prep.setInt(1, <class>_ID);
    <fields:saveField(); separator="\n">
    <arrayFields:saveArrayField(); separator="\n">
    if (prep.executeUpdate () != 1) {
        System.err.println("couldn't save "+o);
    }
}
>>
// END: saveObjectMethod

// START: saveField
saveField(f) ::= <<
prep.set<f.type; format="capitalized">(<i>+1,
    <fieldValue(type=f.type, value={o.<f.name>})>);
>>
// END: saveField

// START: fieldValue
fieldValue(type, value="o") ::= "<javaToSQLValueMap.(type.simpleName)>"
// END: fieldValue

// START: saveArrayField
saveArrayField(f) ::= <<
save_<class>_<f.name>(con, o.<f.name>, <class>_ID);
>>
// END: saveArrayField

// START: saveForeignObjectMethod
saveForeignObjectMethod(field) ::= <<
static void save_<class>_<field.name>(Connection con,
                                      <field.type> <field.name>,
                                      int <class>_ID)
    throws SQLException
{
    if ( <field.name>==null ) return;
    PreparedStatement prep = con.prepareStatement(
        "INSERT into <class>_<field.name> (<field.name>,"+
        "<class>_ID) values (?, ?);");
    for (<field.type.componentType> o : <field.name>) {
        prep.set<field.type.componentType; format="capitalized">(1,
            <fieldValue(type=field.type.componentType)>);
        prep.setInt(2, <class>_ID);
        if (prep.executeUpdate () != 1) {
            System.err.println("couldn't save field <field.name>");
        }
    }
    prep.close();
}
>>
// END: saveForeignObjectMethod

loadObjectMethod() ::= <<
public static <class.name> next<class; format="capitalized">(Connection con,
                                                             ResultSet rs)
    throws SQLException
{
    int <class>_ID = rs.getInt("ID");
    <class.name> o = new <class>();
    <fields:loadField(); separator="\n">
    <arrayFields:loadArrayField(); separator="\n">
    return o;
}
>>
// END: loadObjectMethod

// START: loadField
loadField(f) ::= <<
o.<f.name> = rs.get<f.type; format="capitalized">("<f.name>");
>>
// END: loadField

// START: loadField
loadArrayField(f) ::= <<
o.<f.name> = get_<class>_<f.name>(con, <class>_ID);
>>
// END: loadField

loadForeignObjectMethod(field) ::= <<
static <field.type> get_<class>_<field.name>(Connection con, int ID)
    throws SQLException
{
    String q="SELECT <field.name> FROM <class>_<field.name> WHERE <class>_ID="+ID;
    Statement stat = con.createStatement();
    ResultSet rs = stat.executeQuery(q);
    List\<<field.type.componentType>\> elements = new ArrayList\<<field.type.componentType>\>();
    while ( rs.next() ) {
        elements.add(rs.get<field.type.componentType; format="capitalized">("<field.name>"));
    }
    rs.close();
    stat.close();
    return (<field.type>)elements.toArray(new <field.type.componentType>[0]);
}
>>
